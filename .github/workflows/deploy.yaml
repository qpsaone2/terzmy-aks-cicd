name: Build and Deploy to AKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'dev'

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_NAME: ${{ secrets.ACR_NAME }}
  IMAGE_NAME: myapp
  AKS_CLUSTER: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  NAMESPACE: dev
  STORAGE_ACCOUNT_NAME: ${{ secrets.STORAGE_ACCOUNT_NAME }}
  STORAGE_ACCOUNT_KEY: ${{ secrets.STORAGE_ACCOUNT_KEY }}

jobs:
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    outputs:
      version_tag: ${{ steps.version.outputs.VERSION_TAG }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Generate Version Tag
      id: version
      run: |
        LATEST_VERSION=$(az acr repository show-tags \
          --name ${{ secrets.ACR_NAME }} \
          --repository $IMAGE_NAME \
          --orderby time_desc \
          --output tsv 2>/dev/null | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
        
        if [ -z "$LATEST_VERSION" ]; then
          NEW_VERSION="v1.0.1"
        else
          MAJOR=$(echo $LATEST_VERSION | cut -d. -f1 | sed 's/v//')
          MINOR=$(echo $LATEST_VERSION | cut -d. -f2)
          PATCH=$(echo $LATEST_VERSION | cut -d. -f3)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="v${MAJOR}.${MINOR}.${NEW_PATCH}"
        fi
        
        echo "VERSION_TAG=${NEW_VERSION}" >> $GITHUB_OUTPUT
        echo "‚úÖ New version: ${NEW_VERSION}"
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Login to ACR
      run: |
        az acr login --name ${{ secrets.ACR_NAME }}
    
    - name: Build Docker Image
      run: |
        cd app
        docker build \
          -t $ACR_LOGIN_SERVER/$IMAGE_NAME:latest \
          -t $ACR_LOGIN_SERVER/$IMAGE_NAME:${{ steps.version.outputs.VERSION_TAG }} \
          .
        
        echo "‚úÖ Built image with tags:"
        echo "  - latest"
        echo "  - ${{ steps.version.outputs.VERSION_TAG }}"
    
    - name: Push Image to ACR
      run: |
        docker push $ACR_LOGIN_SERVER/$IMAGE_NAME:latest
        docker push $ACR_LOGIN_SERVER/$IMAGE_NAME:${{ steps.version.outputs.VERSION_TAG }}
        
        echo "‚úÖ Pushed images:"
        echo "  - latest"
        echo "  - ${{ steps.version.outputs.VERSION_TAG }}"
    
    - name: Build Summary
      run: |
        echo "=========================================="
        echo "‚úÖ Build Completed!"
        echo "=========================================="
        echo ""
        echo "üì¶ Version: ${{ steps.version.outputs.VERSION_TAG }}"
        echo "üè∑Ô∏è  Tags: latest, ${{ steps.version.outputs.VERSION_TAG }}"
        echo ""

  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Install kubelogin
      run: |
        if command -v kubelogin &> /dev/null; then
          echo "‚úÖ kubelogin already installed"
          kubelogin --version
        else
          echo "üì¶ Installing kubelogin..."
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.4/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          sudo chmod +x /usr/local/bin/kubelogin
          kubelogin --version
        fi
    
    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ env.AKS_CLUSTER }}
        resource-group: ${{ env.AKS_RESOURCE_GROUP }}
    
    - name: Convert kubeconfig for Azure AD
      run: |
        kubelogin convert-kubeconfig -l azurecli
    
    - name: Test Kubernetes Connection
      run: |
        kubectl get nodes
        kubectl get namespaces
    
    - name: Create Namespace
      run: |
        kubectl apply -f k8s/namespace.yaml
    
    - name: Create/Update Kubernetes Secret
      run: |
        kubectl create secret generic azure-storage-secret \
          --namespace=$NAMESPACE \
          --from-literal=azurestorageaccountname=${{ secrets.STORAGE_ACCOUNT_NAME }} \
          --from-literal=azurestorageaccountkey=${{ secrets.STORAGE_ACCOUNT_KEY }} \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Deploy StorageClass
      run: |
        if ! kubectl get storageclass azureblob-fuse-premium > /dev/null 2>&1; then
          echo "Creating StorageClass..."
          kubectl create -f k8s/storageclass.yaml
        else
          echo "‚úÖ StorageClass already exists"
        fi
    
    - name: Deploy PersistentVolume
      run: |
        if ! kubectl get pv blob-pv-static > /dev/null 2>&1; then
          echo "Creating Static PersistentVolume..."
          kubectl apply -f k8s/pv.yaml
        else
          echo "‚úÖ PersistentVolume already exists"
        fi
    
    - name: Deploy PVC
      run: |
        kubectl apply -f k8s/pvc.yaml
        
        # Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ ÏÉÅÌÉú ÌôïÏù∏
        sleep 3
        PVC_STATUS=$(kubectl get pvc blob-pvc -n dev -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
        
        if [ "$PVC_STATUS" = "Bound" ]; then
          echo "‚úÖ PVC is already Bound"
        else
          echo "‚è≥ Waiting for PVC to be Bound..."
          kubectl wait --for=condition=Bound pvc/blob-pvc -n dev --timeout=60s || \
            (kubectl describe pvc blob-pvc -n dev && exit 1)
        fi
    
    - name: Deploy Application
      run: |
        VERSION_TAG="${{ needs.build.outputs.version_tag }}"
        
        # deployment.yamlÏùò Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ ÏóÖÎç∞Ïù¥Ìä∏
        sed -i "s|image: terzmyacr.azurecr.io/myapp:.*|image: $ACR_LOGIN_SERVER/$IMAGE_NAME:$VERSION_TAG|g" k8s/deployment.yaml
        
        kubectl apply -f k8s/deployment.yaml
        
        echo "‚úÖ Deployed version: $VERSION_TAG"
    
    - name: Deploy Service
      run: |
        kubectl apply -f k8s/service.yaml
    
    - name: Check Rollout Status
      run: |
        kubectl rollout status deployment/app-deployment -n $NAMESPACE --timeout=5m
    
    - name: Display Deployment Info
      run: |
        echo "=========================================="
        echo "‚úÖ Deployment Successful!"
        echo "=========================================="
        echo ""
        echo "üì¶ Deployed Version: ${{ needs.build.outputs.version_tag }}"
        echo ""
        
        echo "=== Pods ==="
        kubectl get pods -n $NAMESPACE -l app=myapp -o wide
        
        echo ""
        echo "=== Service ==="
        kubectl get svc app-service -n $NAMESPACE
        
        echo ""
        EXTERNAL_IP=$(kubectl get svc app-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        if [ -z "$EXTERNAL_IP" ]; then
          echo "‚è≥ External IP pending..."
        else
          echo "üåê Access URL: http://$EXTERNAL_IP"
        fi
        
        echo ""
        echo "=== All Versions in ACR ==="
        az acr repository show-tags \
          --name ${{ secrets.ACR_NAME }} \
          --repository $IMAGE_NAME \
          --orderby time_desc \
          --output table
        
        echo ""
        echo "=== Pod Node Assignment ==="
        kubectl get pods -n $NAMESPACE -l app=myapp -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName,STATUS:.status.phase