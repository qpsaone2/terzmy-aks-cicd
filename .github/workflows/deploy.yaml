name: Deploy to AKS

on:
  workflow_dispatch:
    inputs:
      version_tag:
        description: 'Version tag to deploy (e.g., v1.0.1 or latest)'
        required: true
        default: 'latest'
      environment:
        description: 'Deployment environment'
        required: false
        default: 'dev'

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  IMAGE_NAME: myapp
  AKS_CLUSTER: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  NAMESPACE: dev

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Install kubelogin
      run: |
        if command -v kubelogin &> /dev/null; then
          echo "kubelogin already installed"
          kubelogin --version
        else
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.4/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          sudo chmod +x /usr/local/bin/kubelogin
          kubelogin --version
        fi
    
    - name: Set AKS Context
      uses: azure/aks-set-context@v3
      with:
        cluster-name: ${{ env.AKS_CLUSTER }}
        resource-group: ${{ env.AKS_RESOURCE_GROUP }}
    
    - name: Convert kubeconfig
      run: |
        kubelogin convert-kubeconfig -l azurecli
    
    - name: Create Namespace
      run: |
        kubectl apply -f k8s/namespace.yaml
    
    - name: Create/Update Secret
      run: |
        kubectl create secret generic azure-storage-secret \
          --namespace=$NAMESPACE \
          --from-literal=azurestorageaccountname=${{ secrets.STORAGE_ACCOUNT_NAME }} \
          --from-literal=azurestorageaccountkey=${{ secrets.STORAGE_ACCOUNT_KEY }} \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Deploy StorageClass
      run: |
        if ! kubectl get storageclass azureblob-fuse-premium > /dev/null 2>&1; then
          kubectl create -f k8s/storageclass.yaml
        else
          echo "StorageClass already exists"
        fi
    
    - name: Deploy PVC
      run: |
        kubectl apply -f k8s/pvc.yaml
    
    - name: Deploy Application
      run: |
        VERSION_TAG="${{ inputs.version_tag }}"
        
        if ! kubectl get deployment app-deployment -n $NAMESPACE > /dev/null 2>&1; then
          kubectl apply -f k8s/deployment.yaml
        fi
        
        kubectl set image deployment/app-deployment \
          app=$ACR_LOGIN_SERVER/$IMAGE_NAME:$VERSION_TAG \
          --namespace=$NAMESPACE \
          --record
        
        echo "Deployed version: $VERSION_TAG"
    
    - name: Deploy Service
      run: |
        kubectl apply -f k8s/service.yaml
    
    - name: Check Rollout
      run: |
        kubectl rollout status deployment/app-deployment -n $NAMESPACE --timeout=5m
    
    - name: Deployment Summary
      run: |
        echo "=========================================="
        echo "Deployment Successful!"
        echo "=========================================="
        echo ""
        echo "Version: ${{ inputs.version_tag }}"
        echo ""
        
        kubectl get pods -n $NAMESPACE -l app=myapp -o wide
        echo ""
        
        kubectl get svc app-service -n $NAMESPACE
        echo ""
        
        EXTERNAL_IP=$(kubectl get svc app-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        if [ -z "$EXTERNAL_IP" ]; then
          echo "External IP pending..."
        else
          echo "Access URL: http://$EXTERNAL_IP"
        fi